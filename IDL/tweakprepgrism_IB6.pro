;##############################################################
;# WISPIPE
;# Reduction Pipeline for the WISP program
;# Generated by Sophia Dai 2014
;# Purpose: 
;#       generate catalogs with SEX on the flt images
;# Input:  
;#       F110_clean.list, F160_clean.list or F140_clean.list
;# Output:
;#   direct_clean.list, direct_crclean.list,
;#   direct_clean_catfile.list, direct_crclean_catfile.list 
;#   F110_crclean.list
;#   F160_crclean.list
;#   or F140_crclean.list, F140_crclean_sci.list, F140_crclean_wht.list
;#   tweakprepgrism.py

;###############################################################'
; In version 4
;#  - Ra and dec shifts in direct images are computed in IDL instead than
;#   using the shift files made by tweakreg. Then they are applied to
;#   the original grism exposures using the pyraf task: updatehdr.updatewcs_with_shift
;# In version 5
;#  - The fixpix task is introduced before the astrodrizzle of the
;#   grism exposures into the final tweakreged image.
;#  - The grism final images are astrodrizzled to be tweakreged and
;#   pixel by pixel aligned to the astrodrizzled direct images.
;#  - A new input keyword "pathconf" is introduced. This is the path
;#     of the configuration file folder (CONFIG)
;#  In version 6
;#  - The bad pixel mask used is the updated one (version 6), that
;#     considers also the wagon wheel feature.

pro tweakprepgrism_IB6, field,path0,pathconf

path = expand_path(path0)+'/aXe/'+field+'/'
;path = '/Volumes/Kudo/DATA/WISPS/aXe/Par288-full/'
;tweakprepgrism,'Par288-full','/Volumes/Kudo/DATA/WISPS'




;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; OBS CHECK 
;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
print, 'tweakprepgrism'
J_OBS='NO' ; NO or YES observations in the F102 band
H_OBS='NO' ; NO, F140 or F160
G102_OBS='NO'
G141_OBS='NO'
f110_list='none'
f140_list='none'
f160_list='none'
g102_list='none'
g141_list='none'
;------------------------------------------------
; DIRECT ----
TEST_J=file_test(path+'DATA/DIRECT/F110_clean.list',/zero_length) ; 1 if exists but no content
TEST_JB=file_test(path+'DATA/DIRECT/F110_clean.list')              ; 1 if exists
TEST_H1=file_test(path+'DATA/DIRECT/F140_clean.list',/zero_length) ; 1 if exists but no content
TEST_H1B=file_test(path+'DATA/DIRECT/F140_clean.list')             ; 1 if exists
TEST_H2=file_test(path+'DATA/DIRECT/F160_clean.list',/zero_length) ; 1 if exists but no content
TEST_H2B=file_test(path+'DATA/DIRECT/F160_clean.list')             ; 1 if exists
; GRISMS ----
TEST_G102=file_test(path+'DATA/GRISM/G102_clean.list',/zero_length) ; 1 if exists but no content
TEST_G102B=file_test(path+'DATA/GRISM/G102_clean.list')              ; 1 if exists
TEST_G141=file_test(path+'DATA/GRISM/G141_clean.list',/zero_length) ; 1 if exists but no content
TEST_G141B=file_test(path+'DATA/GRISM/G141_clean.list')              ; 1 if exists
;------------------------------------------------
;     J      +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
IF TEST_J eq 0 and TEST_JB eq 1 then begin
   readcol,path+'DATA/DIRECT/F110_clean.list',f110_list,format=('A')
   if strlowcase(f110_list[0]) ne 'none' and n_elements(f110_list[0]) gt 0 then J_OBS='YES'
ENDIF
;     H      F140 / F160 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
IF TEST_H1 eq 0 and TEST_H1B eq 1 then begin
   readcol,path+'DATA/DIRECT/F140_clean.list',f140_list,format=('A')
   if strlowcase(f140_list[0]) ne 'none' and n_elements(f140_list[0]) gt 0 then H_OBS='F140'
ENDIF
IF TEST_H2 eq 0 and TEST_H2B eq 1 then begin
   readcol,path+'DATA/DIRECT/F160_clean.list',f160_list,format=('A')
   if strlowcase(f160_list[0]) ne 'none' and n_elements(f160_list[0]) gt 0 then H_OBS='F160'
ENDIF
;    G102    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
IF TEST_G102 eq 0 and TEST_G102B eq 1 then begin
   readcol,path+'DATA/GRISM/G102_clean.list',g102_list,format=('A')
   if strlowcase(g102_list[0]) ne 'none' and n_elements(g102_list[0]) gt 0 then G102_OBS='YES'
ENDIF
;    G141    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
IF TEST_G141 eq 0 and TEST_G141B eq 1 then begin
   readcol,path+'DATA/GRISM/G141_clean.list',g141_list,format=('A')
   if strlowcase(g141_list[0]) ne 'none' and n_elements(g141_list[0]) gt 0 then G141_OBS='YES'
ENDIF
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


print, 'HHHHHHHHHHHHHHHHH'
print, TEST_J,TEST_JB
print, TEST_H1,TEST_H1B
print, TEST_H2,TEST_H2B
print, 'J_OBS = '+J_OBS
print, 'H_OBS = '+H_OBS
print, 'G102_OBS = '+G102_OBS
print, 'G141_OBS = '+G141_OBS
print, 'HHHHHHHHHHHHHHHHH'


;readcol,path+'DATA/DIRECT_GRISM/F110_clean.list',f110_list,format=('A')
;readcol,path+'DATA/DIRECT_GRISM/G102_clean.list',g102_list,format=('A')
;readcol,path+'DATA/DIRECT_GRISM/F160_clean.list',f160_list,format=('A')
;readcol,path+'DATA/DIRECT_GRISM/G141_clean.list',g141_list,format=('A')

;if f160_list[0] ne 'none' then begin
; visit160 = strmid(f160_list,4,2)
;endif
;
;if f160_list[0] eq 'none' then begin
; readcol,path+'DATA/DIRECT_GRISM/F140_clean.list',f140_list,format=('A')
; visit140 = strmid(f140_list,4,2)
;endif


IF J_OBS eq 'YES' THEN  visit110 = strmid(f110_list,4,2)
IF H_OBS eq 'F140' THEN visit140 = strmid(f140_list,4,2)
IF H_OBS eq 'F160' THEN visit160 = strmid(f160_list,4,2)

IF G102_OBS eq 'YES' THEN visit102 = strmid(g102_list,4,2)
IF G141_OBS eq 'YES' THEN visit141 = strmid(g141_list,4,2)


;------------------------------------------------------------------------------------------------
readcol,path+'DATA/GRISM/img_size.txt', NXpixels_tot,NYpixels_tot,RA_ref,dec_ref,format='A,A,A,A'
; These quantities are read as strings and used as strings
; DO NOT CONVERT TO LONG OR FLOAT!   
;NXpixels_tot=long(NXpixels_tot)
;NYpixels_tot=long(NYpixels_tot)
;RA_ref=double(RA_ref)
;dec_ref=double(dec_ref)
;------------------------------------------------------------------------------------------------

readcol,path+'DATA/DIRECT/shift_pos_drz_crclean.txt',file_cr_cl,deltax,deltay,deltarot,f='a,f,f,f'
file_cl=strmid(file_cr_cl,0,19)+'.fits'
help, file_cl[0],/str


;Create direct-grism exposure associations
;*****************************************

openw,1, path+'DATA/GRISM/direct_grism_shift.list',width=1000

; GRISM 102 ==============================

IF G102_OBS eq 'YES' THEN BEGIN
 for i=0,n_elements(visit102)-1 do begin
  m=0
  j=0

  IF J_OBS eq 'YES' THEN BEGIN  
   while j lt n_elements(visit110) and m ne 1 do begin
    if visit102[i] eq visit110[j] then begin
     mm = where(file_cl eq f110_list[j])
     printf,1,g102_list[i],'  ',strmid(f110_list[j],0,19)+'_hlet.fits     ',strtrim(deltax[mm[0]],2)+'   '+strtrim(deltay[mm[0]],2)+'   '+strtrim(deltarot[mm[0]],2)
     m = 1
    endif
    j=j+1
   endwhile
   if m eq 0 and j eq n_elements(visit110) then print,'WARNING: ',g102_list[i],' has no associated direct images and will not be tweakreged'
  ENDIF
  
  IF J_OBS ne 'YES' AND H_OBS eq 'F140' THEN BEGIN
   while j lt n_elements(visit140) and m ne 1 do begin
    if visit102[i] eq visit140[j] then begin
     mm = where(file_cl eq f140_list[j])
     printf,1,g102_list[i],'  ',strmid(f140_list[j],0,19)+'_hlet.fits     ',strtrim(deltax[mm[0]],2)+'   '+strtrim(deltay[mm[0]],2)+'   '+strtrim(deltarot[mm[0]],2)
     m = 1
    endif
    j=j+1
   endwhile  
   if m eq 0 and j eq n_elements(visit140) then print,'WARNING: ',g102_list[i],' has no associated direct images and will not be tweakreged'
  ENDIF
  
  IF J_OBS ne 'YES' AND H_OBS eq 'F160' THEN BEGIN
   while j lt n_elements(visit160) and m ne 1 do begin
    if visit102[i] eq visit160[j] then begin
     mm = where(file_cl eq f160_list[j])
     printf,1,g102_list[i],'  ',strmid(f160_list[j],0,19)+'_hlet.fits     ',strtrim(deltax[mm[0]],2)+'   '+strtrim(deltay[mm[0]],2)+'   '+strtrim(deltarot[mm[0]],2)
     m = 1
    endif
    j=j+1
   endwhile 
   if m eq 0 and j eq n_elements(visit160) then print,'WARNING: ',g102_list[i],' has no associated images and will not be tweakreged' 
  ENDIF

 endfor
ENDIF

; GRISM 141 ==============================

IF G141_OBS eq 'YES' THEN BEGIN
 for i=0,n_elements(visit141)-1 do begin
  m=0
  j=0

  IF H_OBS eq 'F160' THEN BEGIN
   while j lt n_elements(visit160) and m ne 1 do begin
    if visit141[i] eq visit160[j] then begin
     mm = where(file_cl eq f160_list[j])
     printf,1,g141_list[i],'  ',strmid(f160_list[j],0,19)+'_hlet.fits     ',strtrim(deltax[mm[0]],2)+'   '+strtrim(deltay[mm[0]],2)+'   '+strtrim(deltarot[mm[0]],2)
     m = 1
    endif
    j=j+1
   endwhile
   if m eq 0 and j eq n_elements(visit160) then print,'WARNING: ',g141_list[i],' has no associated direct images and will not be tweakreged'
  ENDIF

  IF H_OBS eq 'F140' THEN BEGIN
   while j lt n_elements(visit140) and m ne 1 do begin
    if visit141[i] eq visit140[j] then begin
     mm = where(file_cl eq f140_list[j])
     printf,1,g141_list[i],'  ',strmid(f140_list[j],0,19)+'_hlet.fits     ',strtrim(deltax[mm[0]],2)+'   '+strtrim(deltay[mm[0]],2)+'   '+strtrim(deltarot[mm[0]],2)
     m = 1 
    endif
    j=j+1
   endwhile
   if m eq 0 and j eq n_elements(visit140) then print,'WARNING: ',g141_list[i],' has no associated direct images and will not be tweakreged'
  ENDIF

 endfor
ENDIF
; GRISM 141 END ==============================

close,1
free_lun,1



; to generate the python script to get grism_crcleaned.fits files, then
; apply shift from the direct images
; NOTE: This method is not used anymore. I.B.
readcol,path+'DATA/GRISM/direct_grism_shift.list',grism_list,direct_list,shiftx,shifty,format=('A,A,f,f')


;CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
; SHIFT x and SHIFT Y represent delta RA and delta DEC in units of [pixels].
; The updatewcs_with_shift function wants its input shifts in [deg]
; units. In the WRONG documentation, they report instead that the
; input units should be in [pixels].
;CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
DRA      = dblarr(n_elements(grism_list))
Ddec     = dblarr(n_elements(grism_list))
DeltaX   = dblarr(n_elements(grism_list))
DeltaY   = dblarr(n_elements(grism_list))
DELTA_RA = dblarr(n_elements(grism_list))
DELTA_DEC= dblarr(n_elements(grism_list))


kk=0L
while kk lt n_elements(grism_list) do begin

; First thing: for each grism image, open original and tweakreged
; direct image to measure the shift
dir_or_name=path+'DATA/DIRECT/DIRECT_orig/'+strmid(direct_list[kk],0,19)+'.fits'
dir_or=mrdfits(dir_or_name,1,HD_DIR_OR)

dir_twk_name=path+'DATA/DIRECT/'+strmid(direct_list[kk],0,19)+'.fits'
dir_twk=mrdfits(dir_twk_name,1,HD_DIR_TWK)

; GET ASTROMETRIES
EXTAST,HD_DIR_OR,ASTRO_DIR_OR
EXTAST,HD_DIR_TWK,ASTRO_DIR_TWK
; Get x,y size in pixel
NXpixels_DIR_OR=n_elements(dir_or[*,0])
NYpixels_DIR_OR=n_elements(dir_or[0,*])
NXpixels_DIR_TWK=n_elements(dir_twk[*,0])
NYpixels_DIR_TWK=n_elements(dir_twk[0,*])
; get central pixel position (x,y)-->(ra,dec)
central_pix_x_DIR_OR=float(NXpixels_DIR_OR)/2.
central_pix_y_DIR_OR=float(NYpixels_DIR_OR)/2.
XY2AD,central_pix_x_DIR_OR,central_pix_y_DIR_OR,ASTRO_DIR_OR , RA_centralpix_DIR_OR, dec_centralpix_DIR_OR
central_pix_x_DIR_TWK=float(NXpixels_DIR_TWK)/2.
central_pix_y_DIR_TWK=float(NYpixels_DIR_TWK)/2.
XY2AD,central_pix_x_DIR_TWK,central_pix_y_DIR_TWK,ASTRO_DIR_TWK , RA_centralpix_DIR_TWK, dec_centralpix_DIR_TWK
IF central_pix_x_DIR_OR ne central_pix_x_DIR_TWK or central_pix_y_DIR_OR ne central_pix_y_DIR_TWK then print, 'WARNING: GRISM AND DIRECT IMAGE DO NOT HAVE THE SAME PHISICAL SIZE.'

PRINT, 'KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK'
print, RA_centralpix_DIR_OR, dec_centralpix_DIR_OR
print, RA_centralpix_DIR_TWK, dec_centralpix_DIR_TWK
PRINT, 'KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK'

; Compute delta RA and delta dec
DELTA_RA[kk]=RA_centralpix_DIR_TWK-RA_centralpix_DIR_OR
DELTA_DEC[kk]=dec_centralpix_DIR_TWK-dec_centralpix_DIR_OR

print, '><><>< ><><>< ><><>< ><><>< ><><>< ><><><'
print, strmid(direct_list[kk],0,19)+'_crclean.fits'
print,'Dra=',DELTA_RA[kk]
print,'Ddec=',DELTA_DEC[kk]
print,'Applied to ',grism_list[kk]
print, '><><>< ><><>< ><><>< ><><>< ><><>< ><><><'


; Read grism image and header
gimg_name=path+'DATA/GRISM/'+grism_list[kk]
gim=mrdfits(gimg_name,1,HD_gim)
; HD_gim=headfits(gimg_name,EXTEN=1) ; header ext 1
 ; Extract astrometry values
 EXTAST,HD_gim,ASTROREF
 ; Get original x,y size inpixel
 NXpixels=n_elements(gim[*,0])
 NYpixels=n_elements(gim[0,*])
 ; get central pixel position (x,y)-->(ra,dec)
 central_pix_x=float(NXpixels)/2.
 central_pix_y=float(NYpixels)/2.
 XY2AD,central_pix_x,central_pix_y,ASTROREF , RA_centralpix, dec_centralpix
 ; Get original pixel scale from grism image; Compute original pixel scale [arcsec/pix]
 ra1=RA_centralpix
 dec1=dec_centralpix-0.01d
 ra2=ra1
 dec2=dec_centralpix+0.01d
 DELTADEC=dec2-dec1 ;(=0.02°)
 AD2XY, ra1 ,dec1,ASTROREF, xpix1, ypix1
 AD2XY, ra2 ,dec2,ASTROREF, xpix2, ypix2 
 DELTA_PIX_X=xpix2-xpix1
 DELTA_PIX_Y=ypix2-ypix1
 DELTAPIX=sqrt((DELTA_PIX_X^2.)+(DELTA_PIX_Y^2.))
 ORIG_PIXSCALE=(DELTADEC/DELTAPIX)*3600.d ;[arcsec/pix]


 print, 'oooooooooooooooooooooooooooooooooooo'
PRINT, 'ORIGINAL PIXELSCALE grism:',ORIG_PIXSCALE
 print, 'oooooooooooooooooooooooooooooooooooo'
; Get Position Angle from  grism headers
 PA=float(sxpar(HD_gim,'ORIENTAT'))
 PA_rad=PA*!pi/180.

;><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
; Delta ra and delta dec in units of [deg] (shiftx and shifty) are
; already along RA and Dec axis)

; Use the following if you want to use the shifts computed here (above)
Ddec[kk]=-DELTA_dec[kk] ;
DRA[kk]=-DELTA_RA[kk]   ;

print,'LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL'
print, "Delta ra and dec in units of [deg]"
print, " along RA and Dec axis"
print, "Delta RA  ="+string(DRA[kk] )
print, "Delta dec ="+string(Ddec[kk])
print,'LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL'
;><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

kk=kk+1
endwhile

;CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC





spawn,'mkdir '+path+'DATA/GRISM/GRISM_orig/'
spawn,'cp '+path+'DATA/GRISM/*_flt_clean.fits '+path+'DATA/GRISM/GRISM_orig/'

openw,6,path+'DATA/GRISM/'+'tweakprepgrism.py'
printf,6,'import os,string,time'
printf,6,'import sys'
printf,6,'import shutil'
printf,6,'from pyraf import iraf'
printf,6,'from iraf import proto, imred, ccdred'
printf,6,'from iraf import stsdas, dither'
printf,6,'from pyraf.irafpar import IrafParS'
printf,6,'from stsci.tools import teal'
printf,6,'import drizzlepac'
printf,6,'from drizzlepac import tweakreg'
printf,6,'from drizzlepac import astrodrizzle'
printf,6,'from drizzlepac import tweakback'
printf,6,'import glob'
printf,6,'from stwcs import wcsutil'
printf,6,'import stwcs.wcsutil.headerlet' 
printf,6,'from drizzlepac import updatehdr'      


; NEW bad pixel mask VERSION 6.1        ---------
IF G102_OBS eq 'YES' THEN BEGIN
 printf,6,'iraf.fixpix(images="@G102_clean.list//[1]%'+"'"+'",masks="'+expand_path(pathconf)+'/aXe/CONFIG/bp_mask_v6.pl'+'",linterp=1000,cinterp="INDEF")'
 numG102 = n_elements(g102_list)
ENDIF
IF G141_OBS eq 'YES' THEN BEGIN
 printf,6,'iraf.fixpix(images="@G141_clean.list//[1]%'+"'"+'",masks="'+expand_path(pathconf)+'/aXe/CONFIG/bp_mask_v6.pl'+'",linterp=1000,cinterp="INDEF")'
 numG141 = n_elements(g141_list)
ENDIF
; ------------------------------------


;*************************************
       printf,6,'                '

; xxxxxxxxxxxx SOBSTITUTED BY I.B.. New version starts here xxxxxxxxxxxx
; Changes:
;   1) updatewcs=True-->False ; This would cancel the tweakreg wcs
;   solution set before
;   2) --- See below for the other group of astrodr. grism images ---
; NOTE: the following images should be used only as check images and
; for this reason they will not be copied in the final DIRECT_GRISM
; folder.

IF G102_OBS eq 'YES' THEN BEGIN
if numG102 gt 1 then begin
 printf,6,'astrodrizzle.AstroDrizzle("@G102_clean.list", output="G102_orig",num_cores=5,final_wcs=True,final_wht_type="IVM",build=True,updatewcs=False,clean=True,preserve=False)'; Don't use: ,skysub=False)'
endif else begin
 printf,6,'astrodrizzle.AstroDrizzle("@G102_clean.list", output="G102_orig",num_cores=5,final_wcs=True,final_wht_type="IVM",build=True,updatewcs=False,clean=True,preserve=False,median=False,blot=False,driz_cr=False)'; Don't use: ,skysub=False)'
endelse
ENDIF

IF G141_OBS eq 'YES' THEN BEGIN
if numG141 gt 1 then begin
 printf,6,'astrodrizzle.AstroDrizzle("@G141_clean.list", output="G141_orig",num_cores=5,final_wcs=True,final_wht_type="IVM",build=True,updatewcs=False,clean=True,preserve=False)'; Don't use: ,skysub=False)'
endif else begin
 printf,6,'astrodrizzle.AstroDrizzle("@G141_clean.list", output="G141_orig",num_cores=5,final_wcs=True,final_wht_type="IVM",build=True,updatewcs=False,clean=True,preserve=False,median=False,blot=False,driz_cr=False)'; Don't use: ,skysub=False)'
endelse
ENDIF

;; xxxxxxxxxxxx
       
printf,6,'time.sleep(5)'
printf,6,'                '

;apply the shift to each exposure's corresponding grism image
;*************************************
for i = 0, n_elements(grism_list)-1 do begin
printf,6,'print "Updating grism HDR through x,y shifts (computed in tweakprepgrism.pro)"'


 ; 1) Differently from what is reported in the documentation of
 ;  'updatewcs_with_shift', the xsh and ysh required in input shoud be
 ;  in units of degrees (delta_RA and delta_dec) and not in units of
 ;  pixels. This error is corrected here below.

 ; 2) The same shift computed for the science (SCI) frame must be
 ;  replicated for all the other frames in the grism Multi Extenction
 ;  File (that is not a simle fits)

 ;--------------------------------------------------------
 ; TWKG TWKG TWKG TWKG TWKG TWKG TWKG TWKG TWKG TWKG TWKG
 ; TWKG TWKG TWKG TWKG TWKG TWKG TWKG TWKG TWKG TWKG TWKG
 ;--------------------------------------------------------
 ; TWEAKREG OF GRISM EXPOSURES HAPPENS HERE 
 printf,6,'updatehdr.updatewcs_with_shift("'+grism_list[i]+'", "'+grism_list[i]+'", wcsname="Tweakdirect", scale=1.0, xsh= '+strcompress(string(DRA[i]),/remove_all)+', ysh= '+strcompress(string(Ddec[i]),/remove_all) +', fit=None, xrms=None, yrms=None, verbose=True, force=True, sciext="SCI")'
 printf,6,'updatehdr.updatewcs_with_shift("'+grism_list[i]+'", "'+grism_list[i]+'", wcsname="Tweakdirect", scale=1.0, xsh= '+strcompress(string(DRA[i]),/remove_all)+', ysh= '+strcompress(string(Ddec[i]),/remove_all) +', fit=None, xrms=None, yrms=None, verbose=True, force=True, sciext="ERR")'
 printf,6,'updatehdr.updatewcs_with_shift("'+grism_list[i]+'", "'+grism_list[i]+'", wcsname="Tweakdirect", scale=1.0, xsh= '+strcompress(string(DRA[i]),/remove_all)+', ysh= '+strcompress(string(Ddec[i]),/remove_all) +', fit=None, xrms=None, yrms=None, verbose=True, force=True, sciext="DQ")'
 printf,6,'updatehdr.updatewcs_with_shift("'+grism_list[i]+'", "'+grism_list[i]+'", wcsname="Tweakdirect", scale=1.0, xsh= '+strcompress(string(DRA[i]),/remove_all)+', ysh= '+strcompress(string(Ddec[i]),/remove_all) +', fit=None, xrms=None, yrms=None, verbose=True, force=True, sciext="SAMP")'
 printf,6,'updatehdr.updatewcs_with_shift("'+grism_list[i]+'", "'+grism_list[i]+'", wcsname="Tweakdirect", scale=1.0, xsh= '+strcompress(string(DRA[i]),/remove_all)+', ysh= '+strcompress(string(Ddec[i]),/remove_all) +', fit=None, xrms=None, yrms=None, verbose=True, force=True, sciext="TIME")'
;--------------------------------------------------------
; TWKG TWKG TWKG TWKG TWKG TWKG TWKG TWKG TWKG TWKG TWKG
; TWKG TWKG TWKG TWKG TWKG TWKG TWKG TWKG TWKG TWKG TWKG
;--------------------------------------------------------

endfor



; drizzle of the tweakreged grism exposures after tweakreging
;*************************************************************
   printf,6,'                  '
; xxxxxxxxxxxx SOBSTITUTED BY I.B. See here below new version xxxxxxxxxxxx
; xxxxxxxxxxxx SOBSTITUTED BY I.B. New version starts here xxxxxxxxxxxx
; Changes:
;   1) updatewcs=True-->False ; This would cancel the tweakreg wcs
;   solution set before
;   2) Astrodrizzle image of tweakreged grism exposures are renamed
;   adding "_twkpg" (tweakprepgrism) and "_twkpg_orig_scale" for
;   astrodrizzled with the orginal pixel scale.
;   3) They are copied (by new_drizprep.pro) into the DIRECT_GRISM folder but with a
;   different name. Examples: 
;   - GRISM/G102_twk_twkpg.drz.fits --> DIRECT_GRISM/G102_drz.fits
;   - GRISM/G102_twkpg_orig_scale_drz.fits -->
;     DIRECT_GRISM/G102_orig_scale_drz.fits
; ------------------------------------------------------------------
; NOTE: the following images should be used only as check images and
; for this reason they will not be copied in the final DIRECT_GRISM
; folder
; ------------------------------------------------------------------

IF G102_OBS eq 'YES' THEN BEGIN
if numG102 gt 1 then begin
   ; Median IMAGE
   printf,6,'iraf.combine(input="@G102_clean.list//[1]%'+"'"+'",output="G102.fits",combine="median")'
   printf,6,'astrodrizzle.AstroDrizzle("@G102_clean.list", output="G102_twk_twkpg",final_wcs=True,num_cores=5,final_wht_type="IVM",build=True,updatewcs=False,clean=True,preserve=False,final_scale=0.08,final_pixfrac=0.75,final_outnx='+NXpixels_tot+',final_outny='+NYpixels_tot+',final_ra='+RA_ref+',final_dec='+dec_ref+')' ; Don't use: ,skysub=False)'
   printf,6,'astrodrizzle.AstroDrizzle("@G102_clean.list", output="G102_twkpg_orig_scale",final_wcs=True,num_cores=5,final_wht_type="IVM",build=True,updatewcs=False,clean=True,preserve=False)'; Don't use: ,skysub=False)'
 endif else begin
   ; Median IMAGE
   printf,6,'iraf.combine(input="@G102_clean.list//[1]%'+"'"+'",output="G102.fits",combine="median")'
   printf,6,'astrodrizzle.AstroDrizzle("@G102_clean.list", output="G102_twk_twkpg",final_wcs=True,num_cores=5,final_wht_type="IVM",build=True,updatewcs=False,clean=True,preserve=False,final_scale=0.08,final_pixfrac=0.75,median=False,blot=False,driz_cr=False,final_outnx='+NXpixels_tot+',final_outny='+NYpixels_tot+',final_ra='+RA_ref+',final_dec='+dec_ref+')'; Don't use: ,skysub=False)'
   printf,6,'astrodrizzle.AstroDrizzle("@G102_clean.list", output="G102_twkpg_orig_scale",final_wcs=True,num_cores=5,final_wht_type="IVM",build=True,updatewcs=False,clean=True,preserve=False,median=False,blot=False,driz_cr=False)'; Don't use:,skysub=False'
 endelse
ENDIF

IF G141_OBS eq 'YES' THEN BEGIN
 if numG141 gt 1 then begin
  ; Median IMAGE
  printf,6,'iraf.combine(input="@G141_clean.list//[1]%'+"'"+'",output="G141.fits",combine="median")'
  printf,6,'astrodrizzle.AstroDrizzle("@G141_clean.list", output="G141_twk_twkpg",final_wcs=True,num_cores=5,final_wht_type="IVM",build=True,updatewcs=False,clean=True,preserve=False,final_scale=0.08,final_pixfrac=0.75,final_outnx='+NXpixels_tot+',final_outny='+NYpixels_tot+',final_ra='+RA_ref+',final_dec='+dec_ref+')' ; Don't use: ,skysub=False)'
  printf,6,'astrodrizzle.AstroDrizzle("@G141_clean.list", output="G141_twkpg_orig_scale",final_wcs=True,num_cores=5,final_wht_type="IVM",build=True,updatewcs=False,clean=True,preserve=False)' ; Don't use: ,skysub=False)'
 endif else begin
  ; Median IMAGE
  printf,6,'iraf.combine(input="@G141_clean.list//[1]%'+"'"+'",output="G141.fits",combine="median")'
  printf,6,'astrodrizzle.AstroDrizzle("@G141_clean.list", output="G141_twk_twkpg",final_wcs=True,num_cores=5,final_wht_type="IVM",build=True,updatewcs=False,clean=True,preserve=False,final_scale=0.08,final_pixfrac=0.75,median=False,blot=False,driz_cr=False,final_outnx='+NXpixels_tot+',final_outny='+NYpixels_tot+',final_ra='+RA_ref+',final_dec='+dec_ref+')'; Don't use: ,skysub=False)'
  printf,6,'astrodrizzle.AstroDrizzle("@G141_clean.list", output="G141_twkpg_orig_scale",final_wcs=True,num_cores=5,final_wht_type="IVM",build=True,updatewcs=False,clean=True,preserve=False,median=False,blot=False,driz_cr=False)'; Don't use: ,skysub=False)'
endelse
ENDIF

 
 
close,6



; Generate the file lists
;****************************

openw,3, path+'DATA/GRISM/G102_crclean.list'
IF G102_OBS eq 'YES' THEN BEGIN
for ii =0, n_elements(g102_list)-1 do begin
 printf,3,strmid(g102_list[ii],0,9),'_flt_clean_crclean.fits'
endfor
ENDIF
close,3

openw,4, path+'DATA/GRISM/G141_crclean.list'
IF G141_OBS eq 'YES' THEN BEGIN
for ii =0, n_elements(g141_list)-1 do begin
 printf,4,strmid(g141_list[ii],0,9),'_flt_clean_crclean.fits'
endfor
ENDIF
close,4

spawn,'cp '+path+'DATA/GRISM/G102_crclean.list '+path+'DATA/DIRECT_GRISM/'
spawn,'cp '+path+'DATA/GRISM/G141_crclean.list '+path+'DATA/DIRECT_GRISM/'
IF J_OBS eq 'YES' THEN spawn,'cp '+path+'DATA/DIRECT/F110W_twk_drz.fits '+path+'DATA/GRISM/'
IF H_OBS eq 'F140' THEN spawn,'cp '+path+'DATA/DIRECT/F140W_twk_drz.fits '+path+'DATA/GRISM/'
IF H_OBS eq 'F160' THEN spawn,'cp '+path+'DATA/DIRECT/F160W_twk_drz.fits '+path+'DATA/GRISM/'

       
    
end
